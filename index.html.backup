<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-bit Castlevania</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        
        canvas {
            border: 2px solid #444;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        Arrow keys to move, SPACE to jump, X to attack
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script type="module">
        // Vector2.ts
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            add(other) {
                return new Vector2(this.x + other.x, this.y + other.y);
            }
            
            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }
            
            copy() {
                return new Vector2(this.x, this.y);
            }
        }

        // Input.ts
        class Input {
            constructor() {
                this.keys = {};
                this.keysPressed = {};
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (!this.keys[e.code]) {
                        this.keysPressed[e.code] = true;
                    }
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    this.keysPressed[e.code] = false;
                });
            }
            
            isKeyDown(key) {
                return !!this.keys[key];
            }
            
            isKeyPressed(key) {
                return !!this.keysPressed[key];
            }
            
            update() {
                // Clear pressed keys after each frame
                this.keysPressed = {};
            }
        }

        // GameObject.ts
        class GameObject {
            constructor(x, y, width, height) {
                this.position = new Vector2(x, y);
                this.velocity = new Vector2(0, 0);
                this.size = new Vector2(width, height);
                this.active = true;
                this.health = 1;
                this.maxHealth = 1;
            }
            
            update(deltaTime, gameState) {
                // Override in subclasses
            }
            
            render(ctx) {
                // Override in subclasses
            }
            
            getBounds() {
                return {
                    left: this.position.x,
                    right: this.position.x + this.size.x,
                    top: this.position.y,
                    bottom: this.position.y + this.size.y
                };
            }
            
            checkCollision(other) {
                const a = this.getBounds();
                const b = other.getBounds();
                
                return !(a.right < b.left || 
                        a.left > b.right || 
                        a.bottom < b.top || 
                        a.top > b.bottom);
            }
            
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.active = false;
                }
            }
        }

        // Platform.ts
        class Platform extends GameObject {
            constructor(x, y, width, height, color = '#654321') {
                super(x, y, width, height);
                this.color = color;
                this.shadowColor = this.adjustColor(color, -20);
                this.highlightColor = this.adjustColor(color, 20);
            }
            
            // Helper to darken/lighten a color
            adjustColor(color, amount) {
                const hex = color.replace('#', '');
                let r = parseInt(hex.substring(0, 2), 16);
                let g = parseInt(hex.substring(2, 4), 16);
                let b = parseInt(hex.substring(4, 6), 16);
                
                r = Math.max(0, Math.min(255, r + amount));
                g = Math.max(0, Math.min(255, g + amount));
                b = Math.max(0, Math.min(255, b + amount));
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            render(ctx) {
                // Main platform body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.position.x, this.position.y, this.size.x, this.size.y);
                
                // Top highlight
                ctx.fillStyle = this.highlightColor;
                ctx.fillRect(this.position.x, this.position.y, this.size.x, 4);
                
                // Bottom shadow
                ctx.fillStyle = this.shadowColor;
                ctx.fillRect(this.position.x, this.position.y + this.size.y - 3, this.size.x, 3);
                
                // Brick pattern for larger platforms
                if (this.size.x > 50) {
                    ctx.strokeStyle = this.shadowColor;
                    ctx.lineWidth = 1;
                    
                    // Horizontal lines
                    if (this.size.y > 30) {
                        for (let y = this.position.y + 10; y < this.position.y + this.size.y - 5; y += 10) {
                            ctx.beginPath();
                            ctx.moveTo(this.position.x, y);
                            ctx.lineTo(this.position.x + this.size.x, y);
                            ctx.stroke();
                        }
                    }
                    
                    // Vertical lines (brick pattern)
                    const brickWidth = 20;
                    for (let x = this.position.x + brickWidth; x < this.position.x + this.size.x; x += brickWidth) {
                        // Make bricks offset for each row
                        const offset = Math.floor((x - this.position.x) / brickWidth) % 2 === 0 ? 5 : -5;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, this.position.y + offset);
                        ctx.lineTo(x, this.position.y + this.size.y);
                        ctx.stroke();
                    }
                }
            }
        }

        // Player.ts
        class Player extends GameObject {
            constructor(x, y) {
                super(x, y, 32, 48);
                this.health = 16;
                this.maxHealth = 16;
                this.speed = 220;       // Slightly faster movement
                this.jumpPower = 430;   // Higher jumps to reach platforms
                this.grounded = false;
                this.facingRight = true;
                this.attackTimer = 0;
                this.attacking = false;
                this.attackDuration = 0.3;
                this.invulnerable = false;
                this.invulnerabilityTimer = 0;
                this.invulnerabilityDuration = 1.0;
                this.coyoteTime = 0.1;  // Allow jumping shortly after walking off platform
                this.coyoteTimer = 0;   // Timer to track coyote time
            }
            
            update(deltaTime, gameState) {
                this.handleInput(gameState.input, deltaTime);
                this.updatePhysics(deltaTime, gameState);
                this.updateTimers(deltaTime);
                this.handleCollisions(gameState);
            }
            
            handleInput(input, deltaTime) {
                // Movement
                if (input.isKeyDown('ArrowLeft')) {
                    this.velocity.x = -this.speed;
                    this.facingRight = false;
                } else if (input.isKeyDown('ArrowRight')) {
                    this.velocity.x = this.speed;
                    this.facingRight = true;
                } else {
                    this.velocity.x = 0;
                }
                
                // Jump with improved feel - variable height based on how long the jump button is pressed
                if (input.isKeyPressed('Space') && (this.grounded || this.coyoteTimer > 0)) {
                    this.velocity.y = -this.jumpPower;
                    this.grounded = false;
                    this.coyoteTimer = 0; // Used up coyote time
                    
                    // Small vertical boost for more responsive jumps
                    this.position.y -= 5;
                } 
                // Cut jump short if key is released during upward movement (variable jump height)
                else if (!input.isKeyDown('Space') && this.velocity.y < 0) {
                    this.velocity.y *= 0.5; // Reduce upward velocity when jump key released
                }
                
                // Attack
                if (input.isKeyPressed('KeyX') && !this.attacking) {
                    this.attack();
                }
            }
            
            updatePhysics(deltaTime, gameState) {
                // Gravity
                this.velocity.y += 800 * deltaTime;
                
                // Update position
                const nextPosition = this.position.add(this.velocity.multiply(deltaTime));
                
                // Handle platform collisions
                this.grounded = false;
                for (let platform of gameState.platforms) {
                    // Check if player would be colliding with a platform after moving
                    const playerBottom = this.position.y + this.size.y;
                    const nextPlayerBottom = nextPosition.y + this.size.y;
                    
                    // Check if player is falling onto platform
                    if (this.velocity.y > 0 && 
                        playerBottom <= platform.position.y && 
                        nextPlayerBottom >= platform.position.y) {
                        
                        // Check horizontal overlap
                        if (nextPosition.x + this.size.x > platform.position.x && 
                            nextPosition.x < platform.position.x + platform.size.x) {
                            // Land on platform
                            nextPosition.y = platform.position.y - this.size.y;
                            this.velocity.y = 0;
                            this.grounded = true;
                        }
                    }
                }
                
                // Apply the calculated position
                this.position = nextPosition;
                
                // Ground collision (simple)
                if (this.position.y > 400) {
                    this.position.y = 400;
                    this.velocity.y = 0;
                    this.grounded = true;
                }
                
                // Screen boundaries
                if (this.position.x < 0) this.position.x = 0;
                if (this.position.x > 768) this.position.x = 768;
            }
            
            updateTimers(deltaTime) {
                if (this.attacking) {
                    this.attackTimer -= deltaTime;
                    if (this.attackTimer <= 0) {
                        this.attacking = false;
                    }
                }
                
                if (this.invulnerable) {
                    this.invulnerabilityTimer -= deltaTime;
                    if (this.invulnerabilityTimer <= 0) {
                        this.invulnerable = false;
                    }
                }
                
                // Handle coyote time (allowing jumps shortly after leaving platform)
                if (!this.grounded) {
                    if (this.coyoteTimer > 0) {
                        this.coyoteTimer -= deltaTime;
                    }
                } else {
                    this.coyoteTimer = this.coyoteTime;
                }
            }
            
            handleCollisions(gameState) {
                if (this.invulnerable) return;
                
                for (let enemy of gameState.enemies) {
                    if (enemy.active && this.checkCollision(enemy)) {
                        this.takeDamage(1);
                        this.invulnerable = true;
                        this.invulnerabilityTimer = this.invulnerabilityDuration;
                        
                        // Knockback
                        const direction = this.position.x < enemy.position.x ? -1 : 1;
                        this.velocity.x = direction * 150;
                        this.velocity.y = -200;
                        
                        gameState.camera.shake(0.3, 5);
                        break;
                    }
                }
            }
            
            attack() {
                this.attacking = true;
                this.attackTimer = this.attackDuration;
            }
            
            getAttackBounds() {
                if (!this.attacking) return null;
                
                const offset = this.facingRight ? this.size.x : -32;
                return {
                    left: this.position.x + offset,
                    right: this.position.x + offset + 32,
                    top: this.position.y + 8,
                    bottom: this.position.y + this.size.y - 8
                };
            }
            
            render(ctx) {
                ctx.save();
                
                // Flicker when invulnerable
                if (this.invulnerable && Math.floor(Date.now() / 100) % 2) {
                    ctx.globalAlpha = 0.5;
                }
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(this.position.x, this.position.y, this.size.x, this.size.y);
                
                // Face
                ctx.fillStyle = '#FFE4C4';
                ctx.fillRect(this.position.x + 8, this.position.y + 8, 16, 16);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.position.x + 10, this.position.y + 12, 2, 2);
                ctx.fillRect(this.position.x + 20, this.position.y + 12, 2, 2);
                
                // Whip/weapon when attacking
                if (this.attacking) {
                    ctx.fillStyle = '#8B4513';
                    const whipX = this.facingRight ? 
                        this.position.x + this.size.x : 
                        this.position.x - 32;
                    ctx.fillRect(whipX, this.position.y + 16, 32, 4);
                }
                
                ctx.restore();
                
                // Health bar
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(10, 10, 100, 10);
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(10, 10, (this.health / this.maxHealth) * 100, 10);
            }
        }

        // Enemy.ts
        class Enemy extends GameObject {
            constructor(x, y, type = 'skeleton') {
                super(x, y, 24, 32);
                this.type = type;
                this.health = 3;
                this.maxHealth = 3;
                this.speed = 50;
                this.direction = Math.random() > 0.5 ? 1 : -1;
                this.hitTimer = 0;
                this.hitDuration = 0.2;
                this.isHit = false;
            }
            
            update(deltaTime, gameState) {
                this.updateMovement(deltaTime, gameState);
                this.updateTimers(deltaTime);
                this.handlePlayerAttack(gameState);
            }
            
            updateMovement(deltaTime, gameState) {
                // Simple AI - move back and forth
                this.velocity.x = this.direction * this.speed;
                
                // Change direction at screen edges
                if (this.position.x <= 0 || this.position.x >= 776) {
                    this.direction *= -1;
                }
                
                // Gravity
                this.velocity.y += 800 * deltaTime;
                
                // Calculate next position
                const nextPosition = this.position.add(this.velocity.multiply(deltaTime));
                
                // Check if about to walk off current platform
                let willFallOff = true;
                let onPlatform = false;
                
                for (let platform of gameState.platforms) {
                    const enemyBottom = this.position.y + this.size.y;
                    const nextEnemyBottom = nextPosition.y + this.size.y;
                    
                    // Check if currently on this platform
                    if (Math.abs(enemyBottom - platform.position.y) < 2 && 
                        this.position.x + this.size.x > platform.position.x && 
                        this.position.x < platform.position.x + platform.size.x) {
                        
                        onPlatform = true;
                        
                        // Check if next step would be on the platform
                        const nextX = this.position.x + (this.direction * this.speed * deltaTime);
                        const checkX = this.direction > 0 ? nextX + this.size.x : nextX;
                        
                        // If still on platform, we're good
                        if (checkX >= platform.position.x && checkX <= platform.position.x + platform.size.x) {
                            willFallOff = false;
                        }
                    }
                    
                    // Handle landing on platforms when falling
                    if (this.velocity.y > 0 && 
                        enemyBottom <= platform.position.y && 
                        nextEnemyBottom >= platform.position.y) {
                        
                        // Check horizontal overlap
                        if (nextPosition.x + this.size.x > platform.position.x && 
                            nextPosition.x < platform.position.x + platform.size.x) {
                            // Land on platform
                            nextPosition.y = platform.position.y - this.size.y;
                            this.velocity.y = 0;
                            onPlatform = true;
                            willFallOff = false;
                        }
                    }
                }
                
                // If about to walk off the platform, reverse direction
                if (onPlatform && willFallOff) {
                    this.direction *= -1;
                    this.velocity.x = this.direction * this.speed;
                    // Recalculate horizontal position to prevent falling
                    nextPosition.x = this.position.x + (this.velocity.x * deltaTime);
                }
                
                // Apply the calculated position
                this.position = nextPosition;
                
                // Ground collision
                if (this.position.y > 416) {
                    this.position.y = 416;
                    this.velocity.y = 0;
                }
            }
            
            updateTimers(deltaTime) {
                if (this.isHit) {
                    this.hitTimer -= deltaTime;
                    if (this.hitTimer <= 0) {
                        this.isHit = false;
                    }
                }
            }
            
            handlePlayerAttack(gameState) {
                const player = gameState.player;
                const attackBounds = player.getAttackBounds();
                
                if (attackBounds && this.checkCollisionWithBounds(attackBounds) && !this.isHit) {
                    this.takeDamage(1);
                    this.isHit = true;
                    this.hitTimer = this.hitDuration;
                    
                    // Knockback
                    const direction = this.position.x < player.position.x ? -1 : 1;
                    this.velocity.x = direction * 200;
                    this.velocity.y = -150;
                    
                    // Hit pause effect
                    gameState.hitPause(0.1);
                    gameState.camera.shake(0.2, 3);
                }
            }
            
            checkCollisionWithBounds(bounds) {
                const myBounds = this.getBounds();
                return !(myBounds.right < bounds.left || 
                        myBounds.left > bounds.right || 
                        myBounds.bottom < bounds.top || 
                        myBounds.top > bounds.bottom);
            }
            
            render(ctx) {
                ctx.save();
                
                // Flash white when hit
                if (this.isHit) {
                    ctx.fillStyle = '#FFFFFF';
                } else {
                    ctx.fillStyle = this.type === 'skeleton' ? '#F5F5DC' : '#8B0000';
                }
                
                ctx.fillRect(this.position.x, this.position.y, this.size.x, this.size.y);
                
                if (!this.isHit) {
                    // Simple sprite details
                    ctx.fillStyle = '#000';
                    // Eyes
                    ctx.fillRect(this.position.x + 6, this.position.y + 8, 2, 2);
                    ctx.fillRect(this.position.x + 16, this.position.y + 8, 2, 2);
                    // Mouth
                    ctx.fillRect(this.position.x + 10, this.position.y + 14, 4, 2);
                }
                
                ctx.restore();
            }
        }

        // Camera.ts
        class Camera {
            constructor() {
                this.position = new Vector2(0, 0);
                this.shakeTimer = 0;
                this.shakeDuration = 0;
                this.shakeIntensity = 0;
                this.shakeOffset = new Vector2(0, 0);
            }
            
            update(deltaTime) {
                this.updateShake(deltaTime);
            }
            
            updateShake(deltaTime) {
                if (this.shakeTimer > 0) {
                    this.shakeTimer -= deltaTime;
                    
                    const intensity = (this.shakeTimer / this.shakeDuration) * this.shakeIntensity;
                    this.shakeOffset.x = (Math.random() - 0.5) * intensity * 2;
                    this.shakeOffset.y = (Math.random() - 0.5) * intensity * 2;
                } else {
                    this.shakeOffset.x = 0;
                    this.shakeOffset.y = 0;
                }
            }
            
            shake(duration, intensity) {
                this.shakeTimer = duration;
                this.shakeDuration = duration;
                this.shakeIntensity = intensity;
            }
            
            apply(ctx) {
                ctx.translate(this.shakeOffset.x, this.shakeOffset.y);
            }
            
            reset(ctx) {
                ctx.translate(-this.shakeOffset.x, -this.shakeOffset.y);
            }
        }

        // GameState.ts
        class GameState {
            constructor() {
                this.platforms = []; // Initialize platforms first
                this.createPlatforms();
                
                // Initialize player on a platform
                this.player = new Player(100, 330); // Position player on the left platform
                
                this.enemies = [];
                this.input = new Input();
                this.camera = new Camera();
                this.hitPauseTimer = 0;
                this.hitPauseDuration = 0;
                this.spawnTimer = 0;
                this.spawnInterval = 3;
                
                this.spawnInitialEnemies();
            }
            
            createPlatforms() {
                // Create the ground (acts as a platform too)
                this.platforms.push(new Platform(0, 450, 800, 150, '#654321'));
                
                // Create floating platforms - create an interesting level layout
                // Left side platforms
                this.platforms.push(new Platform(50, 350, 100, 20, '#654321'));
                this.platforms.push(new Platform(180, 280, 120, 20, '#654321'));
                this.platforms.push(new Platform(80, 200, 90, 20, '#654321'));
                
                // Middle platforms
                this.platforms.push(new Platform(350, 320, 100, 20, '#654321'));
                this.platforms.push(new Platform(320, 230, 80, 20, '#654321'));
                this.platforms.push(new Platform(300, 140, 70, 20, '#765432'));
                
                // Right side platforms
                this.platforms.push(new Platform(500, 370, 110, 20, '#654321'));
                this.platforms.push(new Platform(580, 290, 100, 20, '#654321'));
                this.platforms.push(new Platform(650, 200, 90, 20, '#654321'));
                
                // Special higher platforms
                this.platforms.push(new Platform(450, 100, 60, 15, '#8B4513'));
                this.platforms.push(new Platform(200, 100, 60, 15, '#8B4513'));
            }
            
            spawnInitialEnemies() {
                // Spawn enemies on different platforms
                if (this.platforms.length > 0) {
                    // Skip the ground platform (index 0)
                    const platformIndices = [2, 5, 8]; // Spawn on different heights
                    
                    for (let i = 0; i < platformIndices.length; i++) {
                        if (this.platforms[platformIndices[i]]) {
                            const platform = this.platforms[platformIndices[i]];
                            const x = platform.position.x + platform.size.x / 2 - 12; // Center on platform
                            const y = platform.position.y - 32; // On top of platform
                            this.enemies.push(new Enemy(x, y));
                        }
                    }
                } else {
                    // Fallback if no platforms defined
                    for (let i = 0; i < 3; i++) {
                        const x = 200 + i * 200;
                        this.enemies.push(new Enemy(x, 300));
                    }
                }
            }
            
            update(deltaTime) {
                // Handle hit pause
                if (this.hitPauseTimer > 0) {
                    this.hitPauseTimer -= deltaTime;
                    return; // Skip all updates during hit pause
                }
                
                this.player.update(deltaTime, this);
                
                for (let enemy of this.enemies) {
                    if (enemy.active) {
                        enemy.update(deltaTime, this);
                    }
                }
                
                // Remove inactive enemies
                this.enemies = this.enemies.filter(enemy => enemy.active);
                
                // Spawn new enemies
                this.spawnTimer += deltaTime;
                if (this.spawnTimer >= this.spawnInterval && this.enemies.length < 5) {
                    this.spawnTimer = 0;
                    
                    // Pick a random elevated platform (skip ground platform)
                    const platformOptions = this.platforms.filter((p) => 
                        p.position.y < 400 && p.position.y > 150);
                    
                    if (platformOptions.length > 0) {
                        // Choose random platform
                        const platform = platformOptions[Math.floor(Math.random() * platformOptions.length)];
                        
                        // Position on platform
                        const x = platform.position.x + Math.random() * (platform.size.x - 24);
                        const y = platform.position.y - 32;
                        
                        this.enemies.push(new Enemy(x, y));
                    } else {
                        // Fallback if no appropriate platforms
                        const side = Math.random() > 0.5 ? 0 : 800;
                        this.enemies.push(new Enemy(side, 300));
                    }
                }
                
                this.camera.update(deltaTime);
                this.input.update();
            }
            
            hitPause(duration) {
                this.hitPauseTimer = duration;
                this.hitPauseDuration = duration;
            }
            
            render(ctx) {
                // Clear screen
                ctx.fillStyle = '#2C1810';
                ctx.fillRect(0, 0, 800, 600);
                
                // Apply camera effects
                this.camera.apply(ctx);
                
                // Draw background elements
                this.drawBackground(ctx);
                
                // Draw platforms
                for (let platform of this.platforms) {
                    platform.render(ctx);
                }
                
                // Draw game objects
                this.player.render(ctx);
                
                for (let enemy of this.enemies) {
                    if (enemy.active) {
                        enemy.render(ctx);
                    }
                }
                
                // Reset camera
                this.camera.reset(ctx);
                
                // Draw UI
                this.drawUI(ctx);
            }
            
            drawBackground(ctx) {
                // Simple castle-like background
                ctx.fillStyle = '#1A0F0A';
                
                // Castle walls
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(i * 160, 450, 160, 150);
                }
                
                // Castle towers
                ctx.fillStyle = '#0F0A07';
                ctx.fillRect(0, 400, 40, 50);
                ctx.fillRect(760, 400, 40, 50);
                ctx.fillRect(380, 350, 40, 100);
                
                // Moon
                ctx.fillStyle = '#FFFACD';
                ctx.beginPath();
                ctx.arc(700, 80, 30, 0, Math.PI * 2);
                ctx.fill();
            }
            
            drawUI(ctx) {
                // Score/status could go here
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '16px monospace';
                ctx.fillText(`Enemies: ${this.enemies.length}`, 10, 50);
            }
        }

        // Game.ts (Main Game Loop)
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameState = new GameState();
                this.lastTime = 0;
                this.running = true;
                
                this.start();
            }
            
            start() {
                requestAnimationFrame((time) => this.gameLoop(time));
            }
            
            gameLoop(currentTime) {
                if (!this.running) return;
                
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;
                
                // Cap delta time to prevent large jumps
                const cappedDeltaTime = Math.min(deltaTime, 0.016);
                
                this.gameState.update(cappedDeltaTime);
                this.gameState.render(this.ctx);
                
                requestAnimationFrame((time) => this.gameLoop(time));
            }
        }

        // Initialize the game
        const game = new Game();
    </script>
</body>
</html>